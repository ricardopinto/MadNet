package cloudflare

import (
	"io"
	"math/big"
)

// GeneratePrivatePublicKeys generates a private and public key pair in G1.
// This private/public key pair is used for the Diffie-Hellman Key Exchange
// encryption part of the distributed key generation protocol and *not* for
// signing. This is because, due to Ethereum Virtual Machine constraints,
// discrete logarithm equality proofs can only take place in G1.
func GeneratePrivatePublicKeys(r io.Reader) (*big.Int, *G1, error) {
	return RandomG1(r)
}

// ConstructPrivatePolyCoefs makes coefficients for private polynomial for
// sharing shared secrets. The shared secret is the constant term (first value).
// This private polynomial is part of the Verifiable Secret Sharing protocol
// in the distributed key generation protocol.
func ConstructPrivatePolyCoefs(r io.Reader, threshold int) ([]*big.Int, error) {
	if threshold < 2 {
		return nil, ErrInvalidThreshold
	}
	privCoefs := make([]*big.Int, threshold+1)
	for j := 0; j < len(privCoefs); j++ {
		randVal, err := randomK(r)
		if err != nil {
			return nil, err
		}
		privCoefs[j] = randVal
	}
	return privCoefs, nil
}

// PrivatePolyEval evaluates the private polynomial to share
// the shared secret with participant j.
func PrivatePolyEval(privCoefs []*big.Int, j int) *big.Int {
	bigJ := big.NewInt(int64(j))
	bigJPower := big.NewInt(1)
	res := new(big.Int).Mod(privCoefs[0], Order)
	for i := 1; i < len(privCoefs); i++ {
		bigJPower.Mul(bigJPower, bigJ)
		tmp := big.NewInt(0)
		tmp.Mul(privCoefs[i], bigJPower)
		tmp.Mod(tmp, Order)
		res.Add(res, tmp)
		res.Mod(res, Order)
	}
	return res
}

// GeneratePublicCoefs computes the public group coefficients from the
// private coefficients. These public coefficients are used to ensure
// the participant is correctly performing the verifiable secret sharing
// protocol.
func GeneratePublicCoefs(privCoefs []*big.Int) []*G1 {
	pubCoefs := make([]*G1, len(privCoefs))
	for j := 0; j < len(privCoefs); j++ {
		pubCoefs[j] = &G1{}
		pubCoefs[j].ScalarBaseMult(privCoefs[j])
	}
	return pubCoefs
}

// GenerateSharedSecretG1 computes the shared secret from the private key privK
// and the public key pubK and outputs the result as an element of G1.
func GenerateSharedSecretG1(privK *big.Int, pubK *G1) *G1 {
	return new(G1).ScalarMult(pubK, privK)
}

// GenerateSharedSecret computes the shared secret with respect to the
// individual private key privK and the public key pubK and outputs both
// x and y coordinates as *big.Int.
func GenerateSharedSecret(privK *big.Int, pubK *G1) (*big.Int, *big.Int) {
	k := GenerateSharedSecretG1(privK, pubK)
	kBytes := k.Marshal()
	kXBytes := kBytes[:numBytes]
	kX := new(big.Int).SetBytes(kXBytes)
	kYBytes := kBytes[numBytes : 2*numBytes]
	kY := new(big.Int).SetBytes(kYBytes)
	return kX, kY
}

// GenerateSecretShares creates the secrets which are to be shared among
// participants during the DKG process. The output of this function will
// then be used as input for GenerateEncryptedShares to be encrypted.
func GenerateSecretShares(pubK *G1, privCoefs []*big.Int, pubKs []*G1) ([]*big.Int, error) {
	n := len(pubKs)
	secretsArray := make([]*big.Int, n-1)
	// userIndex represents location of users
	userIndex, err := findPubKIndex(pubK, pubKs)
	if err != nil {
		return nil, err
	}
	ctr := 0
	for j := 0; j < n; j++ {
		if j == userIndex {
			continue
		}
		idx := j + 1
		secretVal := PrivatePolyEval(privCoefs, idx)
		secretsArray[ctr] = secretVal
		ctr++
	}
	return secretsArray, nil
}

// GenerateEncryptedShares generates the n-1 commitments which will be submitted
// to everyone. These submissions are assumed to be coming from participant i.
// secretsArray are the shared secrets generated by i from GenerateSecretShares
// for the secret sharing protocol, while privK is i's private key.
// pubKs is the array of public keys arranged in the correct order.
//
// To match with ETHDKG implementation, we do not include the commitment
// from i, the participant himself. Even so, this *is* required when
// computing gskj. We assume pubKs are correctly sorted.
func GenerateEncryptedShares(secretsArray []*big.Int, privK *big.Int, pubKs []*G1) ([]*big.Int, error) {
	n := len(pubKs)
	commitments := make([]*big.Int, n-1)
	pubK := new(G1).ScalarBaseMult(privK)
	// userIndex represents location of users
	userIndex, err := findPubKIndex(pubK, pubKs)
	if err != nil {
		return nil, err
	}
	ctr := 0
	for j := 0; j < n; j++ {
		if j == userIndex {
			continue
		}
		partJ := j + 1
		secretValue := secretsArray[ctr]
		encryptedValue := Encrypt(secretValue, privK, pubKs[j], partJ)
		commitments[ctr] = encryptedValue
		ctr++
	}
	return commitments, nil
}

func findPubKIndex(pubK *G1, pubKs []*G1) (int, error) {
	n := len(pubKs)
	// userIndex represents location of users
	userIndex := -1
	foundIndex := false
	for j := 0; j < n; j++ {
		if pubK.IsEqual(pubKs[j]) {
			userIndex = j
			foundIndex = true
			break
		}
	}
	if !foundIndex {
		return -1, ErrMissingIndex
	}
	return userIndex, nil
}

// CondenseCommitments takes all of the commitments from pubK (assumed to be a
// member of the appropriately sorted pubKs array) and condenses them into
// a single array of the correct length which contains all of the encrypted
// values for pubK.
func CondenseCommitments(pubK *G1, combinedCommitments [][]*big.Int, pubKs []*G1) ([]*big.Int, error) {
	n := len(pubKs)
	// userIndex represents location of users
	userIndex, err := findPubKIndex(pubK, pubKs)
	if err != nil {
		return nil, err
	}
	if len(combinedCommitments) != n {
		// There should be n commitments, although 1 will be empty
		return nil, ErrArrayMismatch
	}
	encryptedArray := make([]*big.Int, n-1)
	ctr := 0
	for j := 0; j < n; j++ {
		if j == userIndex {
			continue
		}
		if len(combinedCommitments[j]) != (n - 1) {
			// Each valid commitment should have n-1 entries
			return nil, ErrArrayMismatch
		}
		if j > userIndex {
			encryptedArray[ctr] = combinedCommitments[j][userIndex]
		} else {
			encryptedArray[ctr] = combinedCommitments[j][userIndex-1]
		}
		ctr++
	}
	return encryptedArray, nil
}

// GenerateDecryptedShares generates the n-1 secrets from the encrypted values
// in encryptedArray which were generated by CondenseCommitments.
// Here, pubKs are the appropriately sorted public keys.
func GenerateDecryptedShares(privK *big.Int, encryptedArray []*big.Int, pubKs []*G1) ([]*big.Int, error) {
	n := len(pubKs)
	if len(encryptedArray) != (n - 1) {
		return nil, ErrArrayMismatch
	}
	secretsArray := make([]*big.Int, n-1)
	pubK := new(G1).ScalarBaseMult(privK)
	// userIndex represents location of users
	userIndex, err := findPubKIndex(pubK, pubKs)
	if err != nil {
		return nil, err
	}
	ctr := 0
	partUser := userIndex + 1
	for j := 0; j < n; j++ {
		if j == userIndex {
			continue
		}
		encryptedValue := encryptedArray[ctr]
		secretValue := Decrypt(encryptedValue, privK, pubKs[j], partUser)
		secretsArray[ctr] = secretValue
		ctr++
	}
	return secretsArray, nil
}

// CompareSharedSecret determines if shared secret is valid, returning nil
// if true and raising an error otherwise; pubCoefs are from participant i
// for participant j (who is calling this function).
func CompareSharedSecret(secret *big.Int, j int, pubCoefs []*G1) (bool, error) {
	if secret == nil {
		return false, ErrInvalidSharedSecret
	}
	if j <= 0 {
		return false, ErrInvalid
	}
	for idx := 0; idx < len(pubCoefs); idx++ {
		if pubCoefs[idx] == nil {
			return false, ErrInvalidPoint
		}
	}

	res := &G1{}
	res.Set(pubCoefs[0])

	tmp := &G1{}
	bigJ := big.NewInt(int64(j))
	for k := 1; k < len(pubCoefs); k++ {
		bigK := big.NewInt(int64(k))
		tmpPower := big.NewInt(0)
		tmpPower.Exp(bigJ, bigK, Order)
		tmp.ScalarMult(pubCoefs[k], tmpPower)
		res.Add(res, tmp)
	}

	g1Secret := &G1{}
	g1Secret.ScalarBaseMult(secret)
	if !g1Secret.IsEqual(res) {
		return false, nil
	}
	return true, nil
}

// GenerateGroupSecretKeyPortion generates the portion of the group secret key
// gskJ from the shared secrets.
func GenerateGroupSecretKeyPortion(listOfSharedSecrets []*big.Int) *big.Int {
	gskJ := big.NewInt(0)
	for k := 0; k < len(listOfSharedSecrets); k++ {
		gskJ.Add(gskJ, listOfSharedSecrets[k])
	}
	gskJ.Mod(gskJ, Order)
	return gskJ
}
